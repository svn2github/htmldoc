
<HTML>
<HEAD>
	<STYLE><!--
	H1, H2, H3, H4, H5, H6 { font-family: sans-serif; }
	DIV.indent { margin-left: 3em; }
	--></STYLE>
</HEAD>
<BODY>
<H1 ALIGN="RIGHT">C - HTMLDOC Class Reference</H1>
<P>This appendix provides a complete reference to the classes and structures
provided in the HTMLDOC library.
<H2>Class List</H2>
<UL>

	<LI><A HREF="#hdMargin">class hdMargin</A></LI>

	<LI><A HREF="#hdTree">struct hdTree</A></LI>

	<LI><A HREF="#hdTreeAttr">struct hdTreeAttr</A></LI>

	<LI><A HREF="#hdBorder">struct hdBorder</A></LI>

	<LI><A HREF="#hdFontKernPair">struct hdFontKernPair</A></LI>

	<LI><A HREF="#hdPDFRender">class hdPDFRender</A></LI>

	<LI><A HREF="#hdPSRender">class hdPSRender</A></LI>

	<LI><A HREF="#hdRender">class hdRender</A></LI>

	<LI><A HREF="#hdRenderChapter">struct hdRenderChapter</A></LI>

	<LI><A HREF="#hdRenderHeading">struct hdRenderHeading</A></LI>

	<LI><A HREF="#hdRenderLink">struct hdRenderLink</A></LI>

	<LI><A HREF="#hdRenderNode">struct hdRenderNode</A></LI>

	<LI><A HREF="#hdRenderPage">struct hdRenderPage</A></LI>

	<LI><A HREF="#hdRenderText">struct hdRenderText</A></LI>

	<LI><A HREF="#hdRenderURL">struct hdRenderURL</A></LI>

	<LI><A HREF="#hdStyle">struct hdStyle</A></LI>

	<LI><A HREF="#hdStyleFont">struct hdStyleFont</A></LI>

	<LI><A HREF="#hdStyleMedia">struct hdStyleMedia</A></LI>

	<LI><A HREF="#hdStyleSelector">struct hdStyleSelector</A></LI>

	<LI><A HREF="#hdStyleSheet">struct hdStyleSheet</A></LI>

</UL>

<!-- NEW PAGE -->
<H2><A NAME="hdMargin">class hdMargin</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdMargin</TT> class tracks changes to the margins for a document
in a stack. This is used to manage margins around floating elements such
as images and tables.</P>

<P>Methods:
<A HREF="#hdMargin.bottom">bottom</A>,
<A HREF="#hdMargin.bottom0">bottom0</A>,
<A HREF="#hdMargin.clear">clear</A>,
<A HREF="#hdMargin.clear">clear</A>,
<A HREF="#hdMargin.hdMargin">hdMargin</A>,
<A HREF="#hdMargin.left">left</A>,
<A HREF="#hdMargin.length">length</A>,
<A HREF="#hdMargin.level">level</A>,
<A HREF="#hdMargin.page">page</A>,
<A HREF="#hdMargin.pop">pop</A>,
<A HREF="#hdMargin.push">push</A>,
<A HREF="#hdMargin.right">right</A>,
<A HREF="#hdMargin.top">top</A>,
<A HREF="#hdMargin.width">width</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdMargin._bottom"><TT>_bottom</TT></A></TD>
<TD VALIGN="TOP"><TT>    float	[HD_MARGIN_MAX]</TT></TD>
<TD VALIGN="TOP">Bottom margin stack</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdMargin._left"><TT>_left</TT></A></TD>
<TD VALIGN="TOP"><TT>    float	[HD_MARGIN_MAX]</TT></TD>
<TD VALIGN="TOP">Left margin stack</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdMargin._level"><TT>_level</TT></A></TD>
<TD VALIGN="TOP"><TT>    int		</TT></TD>
<TD VALIGN="TOP">Stack level</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdMargin._page"><TT>_page</TT></A></TD>
<TD VALIGN="TOP"><TT>    int		[HD_MARGIN_MAX]</TT></TD>
<TD VALIGN="TOP">End page stack</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdMargin._right"><TT>_right</TT></A></TD>
<TD VALIGN="TOP"><TT>    float	[HD_MARGIN_MAX]</TT></TD>
<TD VALIGN="TOP">Right margin stack</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdMargin._top"><TT>_top</TT></A></TD>
<TD VALIGN="TOP"><TT>    float	</TT></TD>
<TD VALIGN="TOP">Top margin</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdMargin.bottom">float	bottom()</A></H4>
<DIV CLASS="indent">
<P>The <TT>bottom()</TT> method returns the current bottom margin.

<P><B>Returns</B>
<P>The bottom margin in points.

</DIV>

<H4><A NAME="hdMargin.bottom0">float	bottom0()</A></H4>
<DIV CLASS="indent">
<P>The <TT>bottom0()</TT> method returns the initial bottom margin.

<P><B>Returns</B>
<P>The bottom margin in points.

</DIV>

<H4><A NAME="hdMargin.clear">void	clear()</A></H4>
<DIV CLASS="indent">
<P>The <TT>clear()</TT> method pops all margins off the stack, leaving the
initial margins only.

</DIV>

<H4><A NAME="hdMargin.clear">void	clear(float y, int p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>clear()</TT> method pops all margins earlier than the specified
vertical position and page.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The vertical position on the page in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The page number.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdMargin.hdMargin">hdMargin(float l, float r, float b, float t = 0.0)</A></H4>
<DIV CLASS="indent">
<P>The constructor creates a new margin stack object.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>l</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">Initial left margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>b</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">Initial bottom margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>r</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">Initial right margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>t</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">Top margin in points.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdMargin.left">float	left()</A></H4>
<DIV CLASS="indent">
<P>The <TT>left()</TT> method returns the current left margin.

<P><B>Returns</B>
<P>The left margin in points.

</DIV>

<H4><A NAME="hdMargin.length">float	length()</A></H4>
<DIV CLASS="indent">
<P>The <TT>length()</TT> method returns the current length.

<P><B>Returns</B>
<P>The length in points.

</DIV>

<H4><A NAME="hdMargin.level">int		level()</A></H4>
<DIV CLASS="indent">
<P>The <TT>level()</TT> method returns the current stack depth.

<P><B>Returns</B>
<P>The stack depth.

</DIV>

<H4><A NAME="hdMargin.page">int		page()</A></H4>
<DIV CLASS="indent">
<P>The <TT>page()</TT> method returns the ending page for the current margins.

<P><B>Returns</B>
<P>The ending page number.

</DIV>

<H4><A NAME="hdMargin.pop">void	pop()</A></H4>
<DIV CLASS="indent">
<P>The <TT>pop()</TT> method pops the current margins off the stack. If the
current margins are at the top of the stack, nothing is popped.

</DIV>

<H4><A NAME="hdMargin.push">void	push(float l, float r, float b, int p = 0)</A></H4>
<DIV CLASS="indent">
<P>The <TT>push()</TT> method pushes a new set of margins on the stack.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>l</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The new left margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>r</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The new right margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>b</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The new bottom margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The new ending page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdMargin.right">float	right()</A></H4>
<DIV CLASS="indent">
<P>The <TT>right()</TT> method returns the current right margin.

<P><B>Returns</B>
<P>The right margin in points.

</DIV>

<H4><A NAME="hdMargin.top">float	top()</A></H4>
<DIV CLASS="indent">
<P>The <TT>top()</TT> method returns the top margin.

<P><B>Returns</B>
<P>The top margin in points.

</DIV>

<H4><A NAME="hdMargin.width">float	width()</A></H4>
<DIV CLASS="indent">
<P>The <TT>width()</TT> method returns the current width.

<P><B>Returns</B>
<P>The width in points.

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdTree">struct hdTree</A></H2>
<HR>
<H3>Description</H3>
<P>The hdTree structure holds a single node in an HTML document tree.</P>

<P>Methods:
<A HREF="#hdTree.add">add</A>,
<A HREF="#hdTree.build_index">build_index</A>,
<A HREF="#hdTree.build_index">build_index</A>,
<A HREF="#hdTree.build_list">build_list</A>,
<A HREF="#hdTree.build_toc">build_toc</A>,
<A HREF="#hdTree.compute_size">compute_size</A>,
<A HREF="#hdTree.copy_text">copy_text</A>,
<A HREF="#hdTree.find">find</A>,
<A HREF="#hdTree.fix_url">fix_url</A>,
<A HREF="#hdTree.format_block">format_block</A>,
<A HREF="#hdTree.format_comment">format_comment</A>,
<A HREF="#hdTree.format_contents">format_contents</A>,
<A HREF="#hdTree.format_doc">format_doc</A>,
<A HREF="#hdTree.format_image">format_image</A>,
<A HREF="#hdTree.format_index">format_index</A>,
<A HREF="#hdTree.format_list">format_list</A>,
<A HREF="#hdTree.format_table">format_table</A>,
<A HREF="#hdTree.get_attr">get_attr</A>,
<A HREF="#hdTree.get_cell_size">get_cell_size</A>,
<A HREF="#hdTree.get_element">get_element</A>,
<A HREF="#hdTree.get_meta">get_meta</A>,
<A HREF="#hdTree.get_table_size">get_table_size</A>,
<A HREF="#hdTree.get_text">get_text</A>,
<A HREF="#hdTree.get_title">get_title</A>,
<A HREF="#hdTree.hdTree">hdTree</A>,
<A HREF="#hdTree.insert">insert</A>,
<A HREF="#hdTree.parse_attribute">parse_attribute</A>,
<A HREF="#hdTree.parse_element">parse_element</A>,
<A HREF="#hdTree.parse_entity">parse_entity</A>,
<A HREF="#hdTree.read">read</A>,
<A HREF="#hdTree.real_next">real_next</A>,
<A HREF="#hdTree.real_prev">real_prev</A>,
<A HREF="#hdTree.remove">remove</A>,
<A HREF="#hdTree.set_attr">set_attr</A>,
<A HREF="#hdTree.~hdTree">~hdTree</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.attrs"><TT>attrs</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTreeAttr	*</TT></TD>
<TD VALIGN="TOP">Attributes...</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.child"><TT>child</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">First child entry</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.data"><TT>data</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Text (HD_ELEMENT_NONE or HD_ELEMENT_COMMENT)</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.element"><TT>element</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdElement	</TT></TD>
<TD VALIGN="TOP">Markup element</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.elements"><TT>elements</TT></A></TD>
<TD VALIGN="TOP"><TT>  static const char	*[]</TT></TD>
<TD VALIGN="TOP">Strings for each element...</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.elgroup"><TT>elgroup</TT></A></TD>
<TD VALIGN="TOP"><TT>  static unsigned char	[HD_ELEMENT_MAX]</TT></TD>
<TD VALIGN="TOP">Grouping information for each element...</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.height"><TT>height</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Height of this fragment in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.last_child"><TT>last_child</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">Last child entry</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.link"><TT>link</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">Linked-to</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.nattrs"><TT>nattrs</TT></A></TD>
<TD VALIGN="TOP"><TT>  short		</TT></TD>
<TD VALIGN="TOP">Number of attributes...</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.next"><TT>next</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">Next entry on this level</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.nodebreak"><TT>nodebreak</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		</TT></TD>
<TD VALIGN="TOP">Line/left/right break before this node?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.parent"><TT>parent</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">Parent tree entry</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.prev"><TT>prev</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">Previous entry on this level</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.style"><TT>style</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyle	*</TT></TD>
<TD VALIGN="TOP">Style data</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.whitespace"><TT>whitespace</TT></A></TD>
<TD VALIGN="TOP"><TT>  bool		</TT></TD>
<TD VALIGN="TOP">Whitespace before this node?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTree.width"><TT>width</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Width of this fragment in points</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdTree.add">void			add(hdTree *p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>add()</TT> method adds the current node as the last child of
the specified parent. If the node is a child of another parent, it
is first removed from the old parent.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>hdTree*</TT></TD>
<TD VALIGN="TOP">Parent node.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.build_index">hdTree		*build_index(hdStyleSheet *css, hdFile *wordfile)</A></H4>
<DIV CLASS="indent">
<P>The <TT>build_index()</TT> method creates an index of words from a file.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>wordfile</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">The file containing the list of words.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The document tree containing the index.

</DIV>

<H4><A NAME="hdTree.build_index">hdTree		*build_index(hdStyleSheet *css, int num_phrases, const char **phrases)</A></H4>
<DIV CLASS="indent">
<P>The <TT>build_index()</TT> method creates an index of words from an array of
phrases.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>num_phrases</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The number of word phrases to index.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>phrases</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char**</TT></TD>
<TD VALIGN="TOP">The word phrases to index.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The document tree containing the index.

</DIV>

<H4><A NAME="hdTree.build_list">hdTree		*build_list(hdStyleSheet *css, const char *class_, const char *prefix)</A></H4>
<DIV CLASS="indent">
<P>The <TT>build_list()</TT> method creates a list of figures, tables, etc. based
on the named HTML class.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>class_</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The class to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>prefix</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The prefix to use for generated links.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The document tree containing the list.

</DIV>

<H4><A NAME="hdTree.build_toc">hdTree		*build_toc(hdStyleSheet *css, int levels, bool numbered)</A></H4>
<DIV CLASS="indent">
<P>The <TT>build_toc()</TT> method creates a table of contents with the given
parameters.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>levels</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The number of TOC levels to show.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>numbered</TT></TD>
<TD VALIGN="TOP"><TT>bool</TT></TD>
<TD VALIGN="TOP">If true, headings are automatically numbered.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The document tree containing the table of contents.

</DIV>

<H4><A NAME="hdTree.compute_size">void			compute_size(hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>compute_size()</TT> method computes the width and height of the node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.copy_text">void			copy_text(hdStyleSheet *css, hdTree *p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>copy_text()</TT> method copies all text nodes from the current node
to the new parent node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>hdTree*</TT></TD>
<TD VALIGN="TOP">The new parent node.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.find">hdTree		*find(hdElement e)</A></H4>
<DIV CLASS="indent">
<P>The <TT>find()</TT> method finds the first child node matching the given element.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>e</TT></TD>
<TD VALIGN="TOP"><TT>hdElement</TT></TD>
<TD VALIGN="TOP">The element to find.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>A pointer to the child node or NULL if none is found.

</DIV>

<H4><A NAME="hdTree.fix_url">static char		*fix_url(const char *url, const char *base, const char *path, char *s, int slen)</A></H4>
<DIV CLASS="indent">
<P>The <TT>fix_url()</TT> method converts a relative URL into an absolute URL.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>url</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The URL to convert.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>base</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The base path for the document.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>path</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">A semicolon-separated list of directories and URLs to search.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>char*</TT></TD>
<TD VALIGN="TOP">URL output buffer.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>slen</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The size of the URL output buffer.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The absolute URL.

</DIV>

<H4><A NAME="hdTree.format_block">void			format_block(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_block()</TT> method formats a block node and its children, updating
the width, height, and nodebreak members.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_comment">void			format_comment(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_comment()</TT> method processes HTML comments.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_contents">void			format_contents(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_contents()</TT> method formats a table-of-contents.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_doc">void			format_doc(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_doc()</TT> method formats this node and all child nodes,
updating the width, height, and nodebreak members.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_image">void			format_image(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_image()</TT> method formats an image, updating the width,
height, and nodebreak members.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_index">void			format_index(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_index()</TT> method formats an index.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_list">void			format_list(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_list()</TT> method formats a list of whatever.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.format_table">void			format_table(hdStyleSheet *css, hdMargin *m, float &amp;x, float &amp;y, int &amp;page)</A></H4>
<DIV CLASS="indent">
<P>The <TT>format_table()</TT> method formats a table, updating the width,
height, and nodebreak members.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The margins to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>x</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>y</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The current Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>page</TT></TD>
<TD VALIGN="TOP"><TT>int&amp;</TT></TD>
<TD VALIGN="TOP">The current page.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.get_attr">const char		*get_attr(const char *name)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_attr()</TT> method retrieves the value of a node attribute.
The attribute name is case-insensitive.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>name</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The attribute name.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The string value or NULL if undefined. If the name is
defined without a value, then an empty string is returned.

</DIV>

<H4><A NAME="hdTree.get_cell_size">float			get_cell_size(hdStyleSheet *css, hdMargin *m, float &amp;minwidth, float &amp;prefwidth, float &amp;minheight)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_cell_size()</TT> method determines the size of the table cell.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The current margins.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>minwidth</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The minimum width of the cell.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>prefwidth</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The preferred width of the cell.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>minheight</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The minimum height of the cell.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The required width of the cell or 0 if none is specified.

</DIV>

<H4><A NAME="hdTree.get_element">static hdElement	get_element(const char *name)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_element()</TT> method gets the hdElement constant associated with
the given string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>name</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The element name.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The hdElement constant.

</DIV>

<H4><A NAME="hdTree.get_meta">const char		*get_meta(const char *name)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_meta()</TT> method gets the META data associated with the given name.
If the current node is not a META element then get_meta() recursively
searches the tree for META elements.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>name</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The META name.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The associated string value or NULL if none is count.

</DIV>

<H4><A NAME="hdTree.get_table_size">float			get_table_size(hdStyleSheet *css, hdMargin *m, float &amp;minwidth, float &amp;prefwidth, float &amp;minheight)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_table_size()</TT> method determines the size of a table.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>m</TT></TD>
<TD VALIGN="TOP"><TT>hdMargin*</TT></TD>
<TD VALIGN="TOP">The current margins.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>minwidth</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The minimum width of the table.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>prefwidth</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The preferred width of the table.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>minheight</TT></TD>
<TD VALIGN="TOP"><TT>float&amp;</TT></TD>
<TD VALIGN="TOP">The minimum height of the table.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The required width of the table or 0 if none is specified.

</DIV>

<H4><A NAME="hdTree.get_text">char			*get_text(bool comments = false)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_text()</TT> method returns the text associated with the current
node. If the current node is not HD_ELEMENT_NONE or
HD_ELEMENT_COMMENT, then get_text() recursively combines text
fragments of child nodes as needed.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>comments</TT></TD>
<TD VALIGN="TOP"><TT>bool</TT></TD>
<TD VALIGN="TOP">Whether to include comment text.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The text associated with the current node or NULL if none
is found.

</DIV>

<H4><A NAME="hdTree.get_title">char			*get_title()</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_title()</TT> method returns the text associated with the title
node in the current tree. If the current node is not a
HD_ELEMENT_TITLE element, then get_title() recursively searches the
tree.

<P><B>Returns</B>
<P>The title text or NULL if none is found.

</DIV>

<H4><A NAME="hdTree.hdTree">hdTree(hdElement e = HD_ELEMENT_NONE, const char *d = (const char *)0, hdTree *p = (hdTree *)0)</A></H4>
<DIV CLASS="indent">
<P>The constructor creates a new tree node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>e</TT></TD>
<TD VALIGN="TOP"><TT>hdElement</TT></TD>
<TD VALIGN="TOP">The element type for this node.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>d</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The data for this node, if any.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>hdTree*</TT></TD>
<TD VALIGN="TOP">The parent node, if any.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.insert">void			insert(hdTree *p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>insert()</TT> method inserts the current node as the first child of
the specified parent. If the node is a child of another parent, it
is first removed from the old parent.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>hdTree*</TT></TD>
<TD VALIGN="TOP">Parent node.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.parse_attribute">bool			parse_attribute(hdFile *fp)</A></H4>
<DIV CLASS="indent">
<P>The <TT>parse_attribute()</TT> method parses a single attribute from a file
and adds it to the current node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">File to read from.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>Returns true if the attribute was read correctly, false
otherwise.

</DIV>

<H4><A NAME="hdTree.parse_element">hdElement		parse_element(hdFile *fp)</A></H4>
<DIV CLASS="indent">
<P>The <TT>parse_element()</TT> method parses an element from a file and
initializes the current node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">File to read from.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The HTML element or HD_ELEMENT_ERROR if the element could
not be parsed.

</DIV>

<H4><A NAME="hdTree.parse_entity">void			parse_entity(hdFile *fp, hdStyleSheet *css, char *s, int slen)</A></H4>
<DIV CLASS="indent">
<P>The <TT>parse_entity()</TT> method parses a HTML entity (&amp;lt;, etc.)
from a file and puts the corresponding string representation in
the supplied string buffer.  If the entity is invalid, the
original text is returned.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">File to read from.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>char*</TT></TD>
<TD VALIGN="TOP">The string buffer.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>slen</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The size of the string buffer in bytes.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.read">static hdTree		*read(hdFile *fp, const char *base, const char *path, hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>read()</TT> method reads a HTML document tree from the specified
file.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">File to read from.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>base</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The base path for the file.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>path</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The search path to use.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet to use.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The document tree.

</DIV>

<H4><A NAME="hdTree.real_next">hdTree		*real_next(bool descend = true)</A></H4>
<DIV CLASS="indent">
<P>The <TT>real_next()</TT> method returns the next logical node in the
tree.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>descend</TT></TD>
<TD VALIGN="TOP"><TT>bool</TT></TD>
<TD VALIGN="TOP">Whether to descend into child nodes.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The next logical node.

</DIV>

<H4><A NAME="hdTree.real_prev">hdTree		*real_prev()</A></H4>
<DIV CLASS="indent">
<P>The <TT>real_prev()</TT> method returns the previous logical node in
the tree.

<P><B>Returns</B>
<P>The previous logical node.

</DIV>

<H4><A NAME="hdTree.remove">void			remove()</A></H4>
<DIV CLASS="indent">
<P>The <TT>remove()</TT> method removes the current node from its parent.

</DIV>

<H4><A NAME="hdTree.set_attr">void			set_attr(const char *name, const char *value)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set_attr()</TT> method adds or changes a node attribute.
The attribute name is case-insensitive.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>name</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The name of the attribute.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>value</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The value of the attribute.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdTree.~hdTree">~hdTree()</A></H4>
<DIV CLASS="indent">
<P>The destructor free a tree node.

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdTreeAttr">struct hdTreeAttr</A></H2>
<HR>
<H3>Description</H3>
<P>The hdTreeAttr structure holds attribute information for a node.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTreeAttr.name"><TT>name</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Variable name</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdTreeAttr.value"><TT>value</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Variable value</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

</TABLE></DIV>

</BODY>
</HTML>

<!-- NEW PAGE -->
<H2><A NAME="hdBorder">struct hdBorder</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdBorder</TT> structure holds border attribute information.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdBorder.color"><TT>color</TT></A></TD>
<TD VALIGN="TOP"><TT>  unsigned char		[3]</TT></TD>
<TD VALIGN="TOP">Color of border</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdBorder.color_set"><TT>color_set</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			</TT></TD>
<TD VALIGN="TOP">Is the color set?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdBorder.style"><TT>style</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdBorderStyle		</TT></TD>
<TD VALIGN="TOP">Rendering style of border</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdBorder.width"><TT>width</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">Width of border in points</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdFontKernPair">struct hdFontKernPair</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdFontKernPair</TT> structure contains character kerning
information for a pair of characters...</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdFontKernPair.adjust"><TT>adjust</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">The horizontal adjustment value between characters.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdFontKernPair.first"><TT>first</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">The first character for kerning.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdFontKernPair.second"><TT>second</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">The second character for kerning.</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdPDFRender">class hdPDFRender</A></H2>
<HR>
<H3>Description</H3>
<P>The hdPDFRender class writes PDF files.</P>

<H3>Base Classes</H3>
<P>
<A HREF="#hdRender">hdRender</A>
<H3>Members</H3>

<P>This class does not provide any public members.

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdPSRender">class hdPSRender</A></H2>
<HR>
<H3>Description</H3>
<P>The hdPSRender class writes PostScript files.</P>

<H3>Base Classes</H3>
<P>
<A HREF="#hdRender">hdRender</A>
<H3>Members</H3>

<P>This class does not provide any public members.

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRender">class hdRender</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRender class converts hdTree nodes into pages which can be written
to files or displays.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.alloc_chapters"><TT>alloc_chapters</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Allocated chapters</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.alloc_headings"><TT>alloc_headings</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Allocated headings</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.alloc_imgmaps"><TT>alloc_imgmaps</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Allocated image maps</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.alloc_links"><TT>alloc_links</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Allocated links</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.alloc_pages"><TT>alloc_pages</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Allocated pages</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.background_color"><TT>background_color</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		[3]</TT></TD>
<TD VALIGN="TOP">Current background color</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.background_image"><TT>background_image</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdImage	*</TT></TD>
<TD VALIGN="TOP">Current background image</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.background_position"><TT>background_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		[2]</TT></TD>
<TD VALIGN="TOP">Current background start position</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.background_repeat"><TT>background_repeat</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdBackgroundRepeat </TT></TD>
<TD VALIGN="TOP">Current background repeat mode</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.chapters"><TT>chapters</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderChapter *</TT></TD>
<TD VALIGN="TOP">Chapters</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.css"><TT>css</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleSheet	*</TT></TD>
<TD VALIGN="TOP">Stylesheet data</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.current_chapter"><TT>current_chapter</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Current chapter</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.current_heading"><TT>current_heading</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Current heading</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.doc_date"><TT>doc_date</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Document creation date</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.doc_time"><TT>doc_time</TT></A></TD>
<TD VALIGN="TOP"><TT>  time_t	</TT></TD>
<TD VALIGN="TOP">Document creation time</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.doc_title"><TT>doc_title</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Document title</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.headings"><TT>headings</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderHeading *</TT></TD>
<TD VALIGN="TOP">Headings</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.imgmaps"><TT>imgmaps</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	**</TT></TD>
<TD VALIGN="TOP">Image maps</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.links"><TT>links</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderLink	*</TT></TD>
<TD VALIGN="TOP">Links</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.media"><TT>media</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleMedia	</TT></TD>
<TD VALIGN="TOP">Media attributes</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.num_chapters"><TT>num_chapters</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of chapters</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.num_headings"><TT>num_headings</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of headings</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.num_imgmaps"><TT>num_imgmaps</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of image maps</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.num_links"><TT>num_links</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of links</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.num_pages"><TT>num_pages</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of pages</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.pages"><TT>pages</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderPage	*</TT></TD>
<TD VALIGN="TOP">Pages</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_font"><TT>render_font</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleFont	*</TT></TD>
<TD VALIGN="TOP">Current font</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_rgb"><TT>render_rgb</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		[3]</TT></TD>
<TD VALIGN="TOP">Current drawing color</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_size"><TT>render_size</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Current font size</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_spacing"><TT>render_spacing</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Current text spacing</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_startx"><TT>render_startx</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Current text X margin</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_x"><TT>render_x</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Current X position</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.render_y"><TT>render_y</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Current Y position</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRender.title_page"><TT>title_page</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Non-zero when processing title page</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRenderChapter">struct hdRenderChapter</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderChapter structure holds the start and end pages for
a chapter.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderChapter.first"><TT>first</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">First page in chapter</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderChapter.last"><TT>last</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Last page in chapter</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRenderHeading">struct hdRenderHeading</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderHeading structure holds the page and position of each
heading in a document.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderHeading.node"><TT>node</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTree	*</TT></TD>
<TD VALIGN="TOP">HTML tree node with heading</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderHeading.page"><TT>page</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Page number</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderHeading.top"><TT>top</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Top position</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRenderLink">struct hdRenderLink</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderLink structure holds the positions and pages of
named links.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderLink.name"><TT>name</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Reference name</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderLink.page"><TT>page</TT></A></TD>
<TD VALIGN="TOP"><TT>  short		</TT></TD>
<TD VALIGN="TOP">Page number</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderLink.top"><TT>top</TT></A></TD>
<TD VALIGN="TOP"><TT>  short		</TT></TD>
<TD VALIGN="TOP">Top position</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRenderNode">struct hdRenderNode</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderNode structure describes rendering primitives used when
producing PostScript and PDF output.</P>

<P>Methods:
<A HREF="#hdRenderNode.hdRenderNode">hdRenderNode</A>,
<A HREF="#hdRenderNode.~hdRenderNode">~hdRenderNode</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderNode.height"><TT>height</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Height in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderNode.next"><TT>next</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderNode	*</TT></TD>
<TD VALIGN="TOP">Next rendering node</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderNode.type"><TT>type</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderType	</TT></TD>
<TD VALIGN="TOP">Type of node</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderNode.width"><TT>width</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Width in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderNode.x"><TT>x</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">X position in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderNode.y"><TT>y</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Y position in points</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdRenderNode.hdRenderNode">hdRenderNode(hdRenderType t, float xx, float yy, float w, float h, const void *d = (const void *)0, int alloc_d = 0)</A></H4>
<DIV CLASS="indent">
<P>The constructor creates a new render node with the specified data.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>t</TT></TD>
<TD VALIGN="TOP"><TT>The</TT></TD>
<TD VALIGN="TOP">type of render primitive, HD_RENDERTYPE_TEXT,
HD_RENDERTYPE_IMAGE, HD_RENDERTYPE_BOX, HD_RENDERTYPE_BACKGROUND,
HD_RENDERTYPE_LINK, or HD_RENDERTYPE_FORM.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>xx</TT></TD>
<TD VALIGN="TOP"><TT>The</TT></TD>
<TD VALIGN="TOP">X position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>yy</TT></TD>
<TD VALIGN="TOP"><TT>The</TT></TD>
<TD VALIGN="TOP">Y position in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>w</TT></TD>
<TD VALIGN="TOP"><TT>The</TT></TD>
<TD VALIGN="TOP">width in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>h</TT></TD>
<TD VALIGN="TOP"><TT>The</TT></TD>
<TD VALIGN="TOP">height in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>d</TT></TD>
<TD VALIGN="TOP"><TT>The</TT></TD>
<TD VALIGN="TOP">data associated with the node, if any.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>alloc_d</TT></TD>
<TD VALIGN="TOP"><TT>Whether</TT></TD>
<TD VALIGN="TOP">the data was allocated (1) or not (0).</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdRenderNode.~hdRenderNode">~hdRenderNode()</A></H4>
<DIV CLASS="indent">
<P>The destructor frees all memory associated with the node, including
the data if it was allocated.

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdRenderPage">struct hdRenderPage</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderPage structure holds all of the rendering data for a
page.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.annot_object"><TT>annot_object</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Annotation object</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.background_color"><TT>background_color</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		[3]</TT></TD>
<TD VALIGN="TOP">Background color</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.background_image"><TT>background_image</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdImage	*</TT></TD>
<TD VALIGN="TOP">Background image</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.background_position"><TT>background_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		[2]</TT></TD>
<TD VALIGN="TOP">Background start position</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.background_repeat"><TT>background_repeat</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdBackgroundRepeat </TT></TD>
<TD VALIGN="TOP">Background repeat mode</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.bottom"><TT>bottom</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Bottom margin in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.chapter"><TT>chapter</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Chapter tree</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.duplex"><TT>duplex</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Duplex this page?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.first"><TT>first</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderNode	*</TT></TD>
<TD VALIGN="TOP">First node on page</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.footer"><TT>footer</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*[3]</TT></TD>
<TD VALIGN="TOP">Footers</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.header"><TT>header</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*[3]</TT></TD>
<TD VALIGN="TOP">Headers</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.heading"><TT>heading</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Heading tree</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.landscape"><TT>landscape</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Landscape orientation?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.last"><TT>last</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdRenderNode	*</TT></TD>
<TD VALIGN="TOP">Last node on page</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.left"><TT>left</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Left margin in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.length"><TT>length</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Length of page in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.media_color"><TT>media_color</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Media color</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.media_position"><TT>media_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Media position</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.media_type"><TT>media_type</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Media type</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.page_object"><TT>page_object</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Page object</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.page_text"><TT>page_text</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Page number for TOC</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.right"><TT>right</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Right margin in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.title"><TT>title</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Title tree</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.top"><TT>top</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Top margin in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.types"><TT>types</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Bitwise OR of all nodes</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderPage.width"><TT>width</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Width of page in points</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRenderText">struct hdRenderText</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderText structure</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderText.alloc_string"><TT>alloc_string</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Did we allocate the string?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderText.char_spacing"><TT>char_spacing</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Inter-character spacing</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderText.font"><TT>font</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleFont	*</TT></TD>
<TD VALIGN="TOP">Font for text</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderText.font_size"><TT>font_size</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Size of text in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderText.rgb"><TT>rgb</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		[3]</TT></TD>
<TD VALIGN="TOP">Color of text</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderText.string"><TT>string</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">String pointer</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdRenderURL">struct hdRenderURL</A></H2>
<HR>
<H3>Description</H3>
<P>The hdRenderURL structure describes a single link on a page.</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderURL.alloc_url"><TT>alloc_url</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Did we allocate the URL?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdRenderURL.url"><TT>url</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Link URL</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<P>This class does not provide any public methods.

<!-- NEW PAGE -->
<H2><A NAME="hdStyle">struct hdStyle</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdStyle</TT> structure stores all of the supported style
information for a single style in a stylesheet.</P>

<P>Methods:
<A HREF="#hdStyle.get_border">get_border</A>,
<A HREF="#hdStyle.get_border_style">get_border_style</A>,
<A HREF="#hdStyle.get_border_width">get_border_width</A>,
<A HREF="#hdStyle.get_color">get_color</A>,
<A HREF="#hdStyle.get_format_spacing">get_format_spacing</A>,
<A HREF="#hdStyle.get_length">get_length</A>,
<A HREF="#hdStyle.get_list_style_type">get_list_style_type</A>,
<A HREF="#hdStyle.get_margin">get_margin</A>,
<A HREF="#hdStyle.get_padding">get_padding</A>,
<A HREF="#hdStyle.get_page_break">get_page_break</A>,
<A HREF="#hdStyle.get_pos">get_pos</A>,
<A HREF="#hdStyle.get_subvalue">get_subvalue</A>,
<A HREF="#hdStyle.hdStyle">hdStyle</A>,
<A HREF="#hdStyle.inherit">inherit</A>,
<A HREF="#hdStyle.load">load</A>,
<A HREF="#hdStyle.update">update</A>,
<A HREF="#hdStyle.~hdStyle">~hdStyle</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.background_color"><TT>background_color</TT></A></TD>
<TD VALIGN="TOP"><TT>  unsigned char		[3]</TT></TD>
<TD VALIGN="TOP">The <TT>background-color</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.background_color_set"><TT>background_color_set</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			</TT></TD>
<TD VALIGN="TOP">True if the <TT>background-color</TT> value is set for this style.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.background_image"><TT>background_image</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The <TT>background-image</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.background_position"><TT>background_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			[2]</TT></TD>
<TD VALIGN="TOP">The <TT>background-position</TT> values.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.background_position_rel"><TT>background_position_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*[2]</TT></TD>
<TD VALIGN="TOP">The relative <TT>background-position</TT> values, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.background_repeat"><TT>background_repeat</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdBackgroundRepeat	</TT></TD>
<TD VALIGN="TOP">The <TT>background-repeat</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.border"><TT>border</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdBorder		[4]</TT></TD>
<TD VALIGN="TOP">The <TT>border-left</TT>, <TT>border-right</TT>, <TT>border-top</TT>,
and <TT>border-bottom</TT> values.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.clear"><TT>clear</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdClear		</TT></TD>
<TD VALIGN="TOP">The <TT>clear</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.color"><TT>color</TT></A></TD>
<TD VALIGN="TOP"><TT>  unsigned char		[3]</TT></TD>
<TD VALIGN="TOP">The <TT>color</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.color_set"><TT>color_set</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			</TT></TD>
<TD VALIGN="TOP">True if the <TT>color</TT> value is set for this style.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.display"><TT>display</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdDisplay		</TT></TD>
<TD VALIGN="TOP">The <TT>display</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.float_"><TT>float_</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFloat		</TT></TD>
<TD VALIGN="TOP">The <TT>float</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font"><TT>font</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleFont		*</TT></TD>
<TD VALIGN="TOP">The <TT>font associated with this style.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font_family"><TT>font_family</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The <TT>font-family</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font_size"><TT>font_size</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>font-size</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font_size_rel"><TT>font_size_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The relative <TT>font-size</TT> value, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font_style"><TT>font_style</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontStyle		</TT></TD>
<TD VALIGN="TOP">The <TT>font-style</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font_variant"><TT>font_variant</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontVariant		</TT></TD>
<TD VALIGN="TOP">The <TT>font-variant</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.font_weight"><TT>font_weight</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontWeight		</TT></TD>
<TD VALIGN="TOP">The <TT>font-weight</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.height"><TT>height</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>height</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.height_rel"><TT>height_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The relative <TT>height</TT> value, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.letter_spacing"><TT>letter_spacing</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>letter-spacing</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.line_height"><TT>line_height</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>line-height</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.line_height_rel"><TT>line_height_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The relative <TT>line-height</TT> value, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.list_style_image"><TT>list_style_image</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The <TT>list-style-image</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.list_style_position"><TT>list_style_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdListStylePosition	</TT></TD>
<TD VALIGN="TOP">The <TT>list-style-position</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.list_style_type"><TT>list_style_type</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdListStyleType	</TT></TD>
<TD VALIGN="TOP">The <TT>list-style-type</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.margin"><TT>margin</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			[4]</TT></TD>
<TD VALIGN="TOP">The <TT>margin-left</TT>, <TT>margin-right</TT>, <TT>margin-top</TT>,
and <TT>margin-bottom</TT> values.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.margin_rel"><TT>margin_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*[4]</TT></TD>
<TD VALIGN="TOP">The relative <TT>margin-left</TT>, <TT>margin-right</TT>,
<TT>margin-top</TT>, and <TT>margin-bottom</TT> values, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.num_selectors"><TT>num_selectors</TT></A></TD>
<TD VALIGN="TOP"><TT>  int			</TT></TD>
<TD VALIGN="TOP">Number of selectors for the style record.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.padding"><TT>padding</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			[4]</TT></TD>
<TD VALIGN="TOP">The <TT>padding-left</TT>, <TT>padding-right</TT>, <TT>padding-top</TT>,
and <TT>padding-bottom</TT> values.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.padding_rel"><TT>padding_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*[4]</TT></TD>
<TD VALIGN="TOP">The relative <TT>padding-left</TT>, <TT>padding-right</TT>,
<TT>padding-top</TT>, and <TT>padding-bottom values</TT>, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.page_break_after"><TT>page_break_after</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdPageBreak		</TT></TD>
<TD VALIGN="TOP">The <TT>page-break-after</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.page_break_before"><TT>page_break_before</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdPageBreak		</TT></TD>
<TD VALIGN="TOP">The <TT>page-break-before</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.page_break_inside"><TT>page_break_inside</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdPageBreak		</TT></TD>
<TD VALIGN="TOP">The <TT>page-break-inside</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.position"><TT>position</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			[4]</TT></TD>
<TD VALIGN="TOP">The <TT>position-left</TT>, <TT>position-right</TT>,
<TT>position-top</TT>, and <TT>position-bottom</TT> values.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.position_rel"><TT>position_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*[4]</TT></TD>
<TD VALIGN="TOP">The relative <TT>position-left</TT>, <TT>position-right</TT>,
<TT>position-top</TT>, and <TT>position-bottom</TT> values, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.selectors"><TT>selectors</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleSelector	*</TT></TD>
<TD VALIGN="TOP">Selectors for the style record.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.text_align"><TT>text_align</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTextAlign		</TT></TD>
<TD VALIGN="TOP">The <TT>text-align</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.text_decoration"><TT>text_decoration</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTextDecoration	</TT></TD>
<TD VALIGN="TOP">The <TT>text-decoration</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.text_indent"><TT>text_indent</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>text-indent</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.text_indent_rel"><TT>text_indent_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The relative <TT>text-indent</TT> value, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.text_transform"><TT>text_transform</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdTextTransform	</TT></TD>
<TD VALIGN="TOP">The <TT>text-transform</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.updated"><TT>updated</TT></A></TD>
<TD VALIGN="TOP"><TT>  int			</TT></TD>
<TD VALIGN="TOP">True if relative attributes have been updated in the style record.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.vertical_align"><TT>vertical_align</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdVerticalAlign	</TT></TD>
<TD VALIGN="TOP">The <TT>vertical-align</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.white_space"><TT>white_space</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdWhiteSpace		</TT></TD>
<TD VALIGN="TOP">The <TT>white-space</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.width"><TT>width</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>width</TT> value.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.width_rel"><TT>width_rel</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">The relative <TT>width</TT> value, if any.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyle.word_spacing"><TT>word_spacing</TT></A></TD>
<TD VALIGN="TOP"><TT>  float			</TT></TD>
<TD VALIGN="TOP">The <TT>word-spacing</TT> value.</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdStyle.get_border">float		get_border(int p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_border()</TT> method returns the width in points of the specified
border.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The border position: <TT>HD_POS_LEFT</TT>,
<TT>HD_POS_RIGHT</TT>, <TT>HD_POS_TOP</TT>, or
<TT>HD_POS_BOTTOM</TT>.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The border width in points.

</DIV>

<H4><A NAME="hdStyle.get_border_style">hdBorderStyle	get_border_style(const char *value)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_border_style()</TT> method returns the border style associated
with the specified string value.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>value</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The string to be converted.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The border style associated with the string.

</DIV>

<H4><A NAME="hdStyle.get_border_width">float		get_border_width(const char *value, hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_border_width()</TT> method returns the width in points for the
given string value.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>value</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The border value string.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The width in points.

</DIV>

<H4><A NAME="hdStyle.get_color">static int	get_color(const char *color, hdByte *rgb)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_color()</TT> method converts the string color to a 24-bit
RGB value.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>value</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The color value string.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>rgb</TT></TD>
<TD VALIGN="TOP"><TT>hdByte*</TT></TD>
<TD VALIGN="TOP">The RGB color array.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>1 if the color was converted, 0 otherwise.

</DIV>

<H4><A NAME="hdStyle.get_format_spacing">float		get_format_spacing(int p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_format_spacing()</TT> method returns the
sum of the border, margin, and padding values.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The spacing position: <TT>HD_POS_LEFT</TT>,
<TT>HD_POS_RIGHT</TT>, <TT>HD_POS_TOP</TT>, or
<TT>HD_POS_BOTTOM</TT>.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The spacing value in points.

</DIV>

<H4><A NAME="hdStyle.get_length">float		get_length(const char *length, float max_length, hdStyleSheet *css, int *relative = (int *)0)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_length()</TT> method converts a "length" value to points.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>length</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The length string.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>max_length</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The maximum value for the given axis.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>relative</TT></TD>
<TD VALIGN="TOP"><TT>int*</TT></TD>
<TD VALIGN="TOP">Set to 1 if the length value is relative, 0 otherwise.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The length value in points.

</DIV>

<H4><A NAME="hdStyle.get_list_style_type">hdListStyleType get_list_style_type(const char *value)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_list_style_type()</TT> method returns the list style associated
with a string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>value</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The string value.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The list style integer value.

</DIV>

<H4><A NAME="hdStyle.get_margin">float		get_margin(int p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_margin()</TT> method returns the margin value in points.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The margin position: <TT>HD_POS_LEFT</TT>,
<TT>HD_POS_RIGHT</TT>, <TT>HD_POS_TOP</TT>, or
<TT>HD_POS_BOTTOM</TT>.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The margin value in points.

</DIV>

<H4><A NAME="hdStyle.get_padding">float		get_padding(int p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_padding()</TT> method returns the padding value in points.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The padding position: <TT>HD_POS_LEFT</TT>,
<TT>HD_POS_RIGHT</TT>, <TT>HD_POS_TOP</TT>, or
<TT>HD_POS_BOTTOM</TT>.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The padding value in points.

</DIV>

<H4><A NAME="hdStyle.get_page_break">hdPageBreak	get_page_break(const char *value)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_page_break()</TT> method returns the page break constant
associated with the string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>value</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The value string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The page break constant.

</DIV>

<H4><A NAME="hdStyle.get_pos">int		get_pos(const char *name)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_pos()</TT> method returns the position constant associated
with the string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>name</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The position string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The position constant.

</DIV>

<H4><A NAME="hdStyle.get_subvalue">char		*get_subvalue(char *valueptr)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_subvalue()</TT> method extracts a single value from a property string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>valueptr</TT></TD>
<TD VALIGN="TOP"><TT>char*</TT></TD>
<TD VALIGN="TOP">Pointer to property string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>New string pointer after the property value.

</DIV>

<H4><A NAME="hdStyle.hdStyle">hdStyle(int nsels, hdStyleSelector *sels, hdStyle *p = (hdStyle *)0)</A></H4>
<DIV CLASS="indent">
<P>The <TT>constructor creates a new style record.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>nsels</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The number of selectors for the style.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>sels</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSelector*</TT></TD>
<TD VALIGN="TOP">The selectors for the style.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>hdStyle*</TT></TD>
<TD VALIGN="TOP">The parent style.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyle.inherit">void		inherit(hdStyle *p)</A></H4>
<DIV CLASS="indent">
<P>The <TT>inherit()</TT> method inherits style data from the specified style.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>hdStyle*</TT></TD>
<TD VALIGN="TOP">Parent style.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyle.load">int		load(hdStyleSheet *css, const char *s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>load()</TT> method loads style data from a string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The style string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>0 on success, -1 on error.

</DIV>

<H4><A NAME="hdStyle.update">void		update(hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>update()</TT> method updates all relative values in the style.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyle.~hdStyle">~hdStyle()</A></H4>
<DIV CLASS="indent">
<P>The <TT>destructor free all memory associated with the style record.

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdStyleFont">struct hdStyleFont</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdStyleFont</TT> structure describes a single font that is used
by a stylesheet.</P>

<P>Methods:
<A HREF="#hdStyleFont.get_char">get_char</A>,
<A HREF="#hdStyleFont.get_kerning">get_kerning</A>,
<A HREF="#hdStyleFont.get_num_chars">get_num_chars</A>,
<A HREF="#hdStyleFont.get_width">get_width</A>,
<A HREF="#hdStyleFont.hdStyleFont">hdStyleFont</A>,
<A HREF="#hdStyleFont.read_afm">read_afm</A>,
<A HREF="#hdStyleFont.read_pfm">read_pfm</A>,
<A HREF="#hdStyleFont.read_ttf">read_ttf</A>,
<A HREF="#hdStyleFont.~hdStyleFont">~hdStyleFont</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.ascender"><TT>ascender</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Highest point in font.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.cap_height"><TT>cap_height</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Height of uppercase letters.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.descender"><TT>descender</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Lowest point in font.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.fixed_width"><TT>fixed_width</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">True if this font is fixed width.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.font_file"><TT>font_file</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Font filename.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.full_name"><TT>full_name</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Full font name.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.kerns"><TT>kerns</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontKernPair *</TT></TD>
<TD VALIGN="TOP">Kerning pairs array.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.num_kerns"><TT>num_kerns</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of kerning pairs.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.num_widths"><TT>num_widths</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of widths in array.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.object"><TT>object</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Object number for PDF files.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.ps_name"><TT>ps_name</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">PostScript font name.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.style"><TT>style</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontInternal </TT></TD>
<TD VALIGN="TOP">Internal font style.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.typeface"><TT>typeface</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontFace	</TT></TD>
<TD VALIGN="TOP">Typeface identifier.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.ul_position"><TT>ul_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Offset for underline.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.ul_thickness"><TT>ul_thickness</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Thickness for underline.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.widths"><TT>widths</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		*</TT></TD>
<TD VALIGN="TOP">Character widths for 1pt text.</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleFont.x_height"><TT>x_height</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Height of lowercase letters.</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdStyleFont.get_char">int		get_char(const char *&amp;s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_char()</TT> method returns the next character from the specified
string and updates the string pointer to the next character position.
This method handles multi-byte and single-byte encodings transparently
to the caller.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">A pointer into a string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The character value.

</DIV>

<H4><A NAME="hdStyleFont.get_kerning">int		get_kerning(const char *s, float &amp;tk, float *&amp;kl)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_kerning()</TT> method generates an array of kerning values
as well as a total kerning adjustment for the specified string.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The string to kern.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>tk</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">Variable to hold total kerning value.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>kl</TT></TD>
<TD VALIGN="TOP"><TT>float*</TT></TD>
<TD VALIGN="TOP">Pointer for kerning array for each character.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The number of kerning entries. Normally 1 less
then the total number of chracters in the input string.

</DIV>

<H4><A NAME="hdStyleFont.get_num_chars">int		get_num_chars(const char *s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_num_chars()</TT> method returns the actual number of
characters in the given string and handles multi-byte and
single-byte encodings transparently to the caller.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">A pointer to the string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The number of characters in the string.

</DIV>

<H4><A NAME="hdStyleFont.get_width">float		get_width(const char *s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_width()</TT> method returns the width of a string, including
adjustments for kerning. The width value is scaled for a point
size of 1.0.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">A pointer to the string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The width of the string.

</DIV>

<H4><A NAME="hdStyleFont.hdStyleFont">hdStyleFont(hdStyleSheet *css, hdFontFace t, hdFontInternal s, const char *n)</A></H4>
<DIV CLASS="indent">
<P>The <TT>constructor creates a new font record for the specified font
name and loads the necessary font width and kerning information.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">A pointer to the style sheet.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>t</TT></TD>
<TD VALIGN="TOP"><TT>hdFontFace</TT></TD>
<TD VALIGN="TOP">The font typeface index.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>hdFontInternal</TT></TD>
<TD VALIGN="TOP">The font style index.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>n</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The PostScript name of the font.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleFont.read_afm">int		read_afm(hdFile *fp, hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>read_afm()</TT> method loads font widths from an AFM file.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">The file to read from.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>0 on success, -1 on error.

</DIV>

<H4><A NAME="hdStyleFont.read_pfm">int		read_pfm(hdFile *fp, hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>read_pfm()</TT> method loads font widths from a PFM file.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">The file to read from.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>0 on success, -1 on error.

</DIV>

<H4><A NAME="hdStyleFont.read_ttf">int		read_ttf(hdFile *fp, hdStyleSheet *css)</A></H4>
<DIV CLASS="indent">
<P>The <TT>read_ttf()</TT> method loads font widths from a TTF file.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>fp</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">The file to read from.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>css</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSheet*</TT></TD>
<TD VALIGN="TOP">The stylesheet.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>0 on success, -1 on error.

</DIV>

<H4><A NAME="hdStyleFont.~hdStyleFont">~hdStyleFont()</A></H4>
<DIV CLASS="indent">
<P>The <TT>destructor free all memory associated with the font.

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdStyleMedia">struct hdStyleMedia</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdStyleMedia</TT> structure describes the output media
attributes.</P>

<P>Methods:
<A HREF="#hdStyleMedia.hdStyleMedia">hdStyleMedia</A>,
<A HREF="#hdStyleMedia.set_margins">set_margins</A>,
<A HREF="#hdStyleMedia.set_orientation">set_orientation</A>,
<A HREF="#hdStyleMedia.set_size">set_size</A>,
<A HREF="#hdStyleMedia.set_size">set_size</A>,
<A HREF="#hdStyleMedia.update_printable">update_printable</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.media_color"><TT>media_color</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Current media color</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.media_position"><TT>media_position</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Current media position</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.media_type"><TT>media_type</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Current media type</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.orientation"><TT>orientation</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdOrientation	</TT></TD>
<TD VALIGN="TOP">Orientation of the page</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_bottom"><TT>page_bottom</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Bottom position in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_left"><TT>page_left</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Left position in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_length"><TT>page_length</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Page length in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_print_length"><TT>page_print_length</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Printable length in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_print_width"><TT>page_print_width</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Printable width in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_right"><TT>page_right</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Right position in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_top"><TT>page_top</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Top position in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.page_width"><TT>page_width</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Page width in points</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.sides"><TT>sides</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdSides	</TT></TD>
<TD VALIGN="TOP">Format single or double-sided?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleMedia.size_name"><TT>size_name</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		[64]</TT></TD>
<TD VALIGN="TOP">Page size name</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdStyleMedia.hdStyleMedia">hdStyleMedia()</A></H4>
<DIV CLASS="indent">
<P>The <TT>constructor creates a new hdStyleMedia structure.

</DIV>

<H4><A NAME="hdStyleMedia.set_margins">void		set_margins(float l, float b, float r, float t)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set_margins()</TT> method sets the page margins.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>l</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The left margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>b</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The bottom margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>r</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The right margin in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>t</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The top margin in points.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleMedia.set_orientation">void		set_orientation(hdOrientation o)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set_orientation()</TT> method sets the orientation of the page.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>o</TT></TD>
<TD VALIGN="TOP"><TT>hdOrientation</TT></TD>
<TD VALIGN="TOP">The orientation of the page:
<TT>HD_ORIENTATION_PORTRAIT</TT>,
<TT>HD_ORIENTATION_LANDSCAPE</TT>,
<TT>HD_ORIENTATION_REVERSE_PORTRAIT</TT>, or
<TT>HD_ORIENTATION_REVERSE_LANDSCAPE</TT>.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleMedia.set_size">void		set_size(float w, float l)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set_size()</TT> method sets the page dimensions by number.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>w</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The width in points.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>l</TT></TD>
<TD VALIGN="TOP"><TT>float</TT></TD>
<TD VALIGN="TOP">The length in points.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleMedia.set_size">void		set_size(const char *name)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set_size()</TT> method sets the page dimensions by name.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>name</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The size name.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleMedia.update_printable">void		update_printable()</A></H4>
<DIV CLASS="indent">
<P>The <TT>update_printable()</TT> method updates the printable width and
length for the current dimensions and margins.

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdStyleSelector">struct hdStyleSelector</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdStyleSelector</TT> structure is used to select specific styles
in a stylesheet.</P>

<P>Methods:
<A HREF="#hdStyleSelector.clear">clear</A>,
<A HREF="#hdStyleSelector.hdStyleSelector">hdStyleSelector</A>,
<A HREF="#hdStyleSelector.set">set</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSelector.class_"><TT>class_</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">Class name for selection</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSelector.element"><TT>element</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdElement		</TT></TD>
<TD VALIGN="TOP">Element for selection</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSelector.id"><TT>id</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">ID for selection</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSelector.pseudo"><TT>pseudo</TT></A></TD>
<TD VALIGN="TOP"><TT>  char			*</TT></TD>
<TD VALIGN="TOP">Pseudo-class for selection</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdStyleSelector.clear">void	clear()</A></H4>
<DIV CLASS="indent">
<P>The <TT>clear()</TT> method resets the selector values, freeing memory as needed.

</DIV>

<H4><A NAME="hdStyleSelector.hdStyleSelector">hdStyleSelector()</A></H4>
<DIV CLASS="indent">
<P>The <TT>constructor creates a new, blank selector.

</DIV>

<H4><A NAME="hdStyleSelector.set">void	set(hdElement e, const char *c, const char *p, const char *i)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set()</TT> method sets the selector values.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>e</TT></TD>
<TD VALIGN="TOP"><TT>hdElement</TT></TD>
<TD VALIGN="TOP">The HTML element.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>c</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The HTML CLASS attribute.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The HTML pseudo-class attribute (link, visited, etc.)
</TD></TR>

<TR><TD VALIGN="TOP"><TT>i</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The HTML ID attribute.</TD></TR>

</TABLE></DIV>

</DIV>

<!-- NEW PAGE -->
<H2><A NAME="hdStyleSheet">struct hdStyleSheet</A></H2>
<HR>
<H3>Description</H3>
<P>The <TT>hdStyleSheet</TT> structure holds a style sheet for a
document.</P>

<P>Methods:
<A HREF="#hdStyleSheet.add_style">add_style</A>,
<A HREF="#hdStyleSheet.find_font">find_font</A>,
<A HREF="#hdStyleSheet.find_style">find_style</A>,
<A HREF="#hdStyleSheet.find_style">find_style</A>,
<A HREF="#hdStyleSheet.get_glyph">get_glyph</A>,
<A HREF="#hdStyleSheet.get_private_style">get_private_style</A>,
<A HREF="#hdStyleSheet.hdStyleSheet">hdStyleSheet</A>,
<A HREF="#hdStyleSheet.load">load</A>,
<A HREF="#hdStyleSheet.pattern">pattern</A>,
<A HREF="#hdStyleSheet.read">read</A>,
<A HREF="#hdStyleSheet.set_charset">set_charset</A>,
<A HREF="#hdStyleSheet.update_styles">update_styles</A>,
<A HREF="#hdStyleSheet.~hdStyleSheet">~hdStyleSheet</A>
</P>

<H3>Members</H3>

<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Member</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.alloc_styles"><TT>alloc_styles</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Allocate style slots</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.charset"><TT>charset</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*</TT></TD>
<TD VALIGN="TOP">Character set</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.default_media"><TT>default_media</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleMedia	</TT></TD>
<TD VALIGN="TOP">Default media attributes from stylesheet</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.elements"><TT>elements</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		[HD_ELEMENT_MAX]</TT></TD>
<TD VALIGN="TOP">First style for each element</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.encoding"><TT>encoding</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdFontEncoding </TT></TD>
<TD VALIGN="TOP">Character encoding</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.font_names"><TT>font_names</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		*[HD_FONTFACE_MAX]</TT></TD>
<TD VALIGN="TOP">Names of base fonts...</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.fonts"><TT>fonts</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleFont	*[HD_FONTFACE_MAX][HD_FONTINTERNAL_MAX]</TT></TD>
<TD VALIGN="TOP">Array of fonts</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.glyphs"><TT>glyphs</TT></A></TD>
<TD VALIGN="TOP"><TT>  char		**</TT></TD>
<TD VALIGN="TOP">Glyphs in charset</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.grayscale"><TT>grayscale</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Grayscale output?</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.max_selectors"><TT>max_selectors</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		[HD_ELEMENT_MAX]</TT></TD>
<TD VALIGN="TOP">Maximum number of selectors in styles</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.media"><TT>media</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyleMedia	</TT></TD>
<TD VALIGN="TOP">Current media attributes</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.num_fonts"><TT>num_fonts</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of fonts defined</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.num_glyphs"><TT>num_glyphs</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of glyphs in charset</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.num_styles"><TT>num_styles</TT></A></TD>
<TD VALIGN="TOP"><TT>  int		</TT></TD>
<TD VALIGN="TOP">Number of styles</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.ppi"><TT>ppi</TT></A></TD>
<TD VALIGN="TOP"><TT>  float		</TT></TD>
<TD VALIGN="TOP">Pixel resolution</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.private_id"><TT>private_id</TT></A></TD>
<TD VALIGN="TOP"><TT>  unsigned	</TT></TD>
<TD VALIGN="TOP">Private style ID</TD></TR>

<TR><TD VALIGN="TOP"><A NAME="hdStyleSheet.styles"><TT>styles</TT></A></TD>
<TD VALIGN="TOP"><TT>  hdStyle	**</TT></TD>
<TD VALIGN="TOP">Array of styles</TD></TR>

</TABLE></DIV>

<H3>Methods</H3>

<H4><A NAME="hdStyleSheet.add_style">void		add_style(hdStyle *s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>add_style()</TT> method adds a style to the stylesheet.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>hdStyle*</TT></TD>
<TD VALIGN="TOP">The style to add.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleSheet.find_font">hdStyleFont	*find_font(hdStyle *s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>find_font()</TT> method finds the font used by a style.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>hdStyle*</TT></TD>
<TD VALIGN="TOP">The style.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>A pointer to the font for the style.

</DIV>

<H4><A NAME="hdStyleSheet.find_style">hdStyle	*find_style(hdTree *t)</A></H4>
<DIV CLASS="indent">
<P>The <TT>find_style()</TT> method finds the matching style for the given document
tree node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>t</TT></TD>
<TD VALIGN="TOP"><TT>hdTree*</TT></TD>
<TD VALIGN="TOP">The document tree node.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>A pointer to the matching style, or NULL if no matching style
is available.

</DIV>

<H4><A NAME="hdStyleSheet.find_style">hdStyle	*find_style(int nsels, hdStyleSelector *sels, int exact = 0)</A></H4>
<DIV CLASS="indent">
<P>The <TT>find_style()</TT> method finds the matching style for the given selectors.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>nsels</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The number of selectors.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>sels</TT></TD>
<TD VALIGN="TOP"><TT>hdStyleSelector*</TT></TD>
<TD VALIGN="TOP">The selector array.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>exact</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">1 if an exact match is needed, 0 for a close match.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>A pointer to the matching style, or NULL if no matching style
is available.

</DIV>

<H4><A NAME="hdStyleSheet.get_glyph">int		get_glyph(const char *s)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_glyph()</TT> method returns the character code for the given character
name. Both HTML and PostScript glyph names are recognized and supported.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The character name string.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>The character code or -1 if the name is unknown.

</DIV>

<H4><A NAME="hdStyleSheet.get_private_style">hdStyle	*get_private_style(hdTree *t)</A></H4>
<DIV CLASS="indent">
<P>The <TT>get_private_style()</TT> method generates a private style for the given
document tree node.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>t</TT></TD>
<TD VALIGN="TOP"><TT>hdTree*</TT></TD>
<TD VALIGN="TOP">The document tree node.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>A pointer to a new, private style record.

</DIV>

<H4><A NAME="hdStyleSheet.hdStyleSheet">hdStyleSheet()</A></H4>
<DIV CLASS="indent">
<P>The constructor creates a new, empty stylesheet.

</DIV>

<H4><A NAME="hdStyleSheet.load">int		load(hdFile *f, const char *path = (const char *)0)</A></H4>
<DIV CLASS="indent">
<P>The <TT>load()</TT> method loads a stylesheet from a file stream.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>f</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">A pointer to the file stream.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>path</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">A search path to be used by any included files.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>0 on success, -1 on failure.

</DIV>

<H4><A NAME="hdStyleSheet.pattern">void		pattern(const char *r, char p[256])</A></H4>
<DIV CLASS="indent">
<P>The <TT>pattern()</TT> method initializes a regex character pattern that is used
when reading stylesheets.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>r</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The regex character pattern.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>char[256]</TT></TD>
<TD VALIGN="TOP">Initialized with true/false values for each character in
the pattern.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleSheet.read">char		*read(hdFile *f, const char *p, char *s, int slen)</A></H4>
<DIV CLASS="indent">
<P>The <TT>read()</TT> method reads a single string from a file stream using the
specified pattern initialized by the pattern()</TT> method.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>f</TT></TD>
<TD VALIGN="TOP"><TT>hdFile*</TT></TD>
<TD VALIGN="TOP">The file stream to read from.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>p</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The pattern array initialized by the pattern()
method.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>s</TT></TD>
<TD VALIGN="TOP"><TT>char*</TT></TD>
<TD VALIGN="TOP">The string buffer.
</TD></TR>

<TR><TD VALIGN="TOP"><TT>slen</TT></TD>
<TD VALIGN="TOP"><TT>int</TT></TD>
<TD VALIGN="TOP">The size of the string buffer.</TD></TR>

</TABLE></DIV>

<P><B>Returns</B>
<P>A pointer to the string that was read or NULL if no string
could be read that matched the input pattern.

</DIV>

<H4><A NAME="hdStyleSheet.set_charset">void		set_charset(const char *cs)</A></H4>
<DIV CLASS="indent">
<P>The <TT>set_charset()</TT> method sets the current character encoding to the named
IANA-defined character set.

<P><B>Parameters</B>
<DIV CLASS="indent"><TABLE BORDER="1" CELLPADDING="5">
<TR BGCOLOR="#cccccc"><TH>Name</TH><TH>Data&nbsp;Type</TH><TH>Description</TH></TR>

<TR><TD VALIGN="TOP"><TT>cs</TT></TD>
<TD VALIGN="TOP"><TT>const&nbsp;char*</TT></TD>
<TD VALIGN="TOP">The character set name.</TD></TR>

</TABLE></DIV>

</DIV>

<H4><A NAME="hdStyleSheet.update_styles">void		update_styles()</A></H4>
<DIV CLASS="indent">
<P>The <TT>update_styles()</TT> method updates all of the relative style information
in the stylesheet.

</DIV>

<H4><A NAME="hdStyleSheet.~hdStyleSheet">~hdStyleSheet()</A></H4>
<DIV CLASS="indent">
<P>The destructor frees the stylesheet including all styles and
fonts in it.

</DIV>

</TABLE></DIV>

</BODY>
</HTML>
